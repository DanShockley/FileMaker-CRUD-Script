<fmxmlsnippet type="FMObjectList">
  <CustomFunction id="1" functionArity="2" visible="True" parameters="name;value" name="#">
    <Calculation>
      <![CDATA["<:" & Substitute( name; ["="; "/="]; [":"; "/:"] ; [">"; "/>"]; ["<" ; "/<"]   ) & ":=" 
                & Substitute( value; ["="; "/="]; [":"; "/:"] ; [">"; "/>"]; ["<" ; "/<"]   ) & ":>"]]>
</Calculation>
  </CustomFunction>
  <CustomFunction id="2" functionArity="1" visible="True" parameters="name" name="#P">
    <Calculation>
      <![CDATA[Let( 
dict = Get( ScriptParameter )
;

Let( [
              match="<:" & Substitute( name ; ["="; "/="]; [":"; "/:"] ; [">"; "/>"]; ["<" ; "/<"]   ) & ":=";
              pstart = Position(dict; match; 1; 1);
              start = pstart + Length(match);
              end = Position(dict ; ":>"; start; 1);
              len = If(end = 0; 999999999; end - start)];

              If (pstart = 0; ""; 
              Substitute(Middle(dict; start; len); ["/:"; ":"]; ["/="; "="] ; ["/>"; ">"] ; ["/<" ; "<" ]))
)

)]]>
</Calculation>
  </CustomFunction>
  <CustomFunction id="3" functionArity="1" visible="True" parameters="name" name="#R">
    <Calculation>
      <![CDATA[Let( [
              dict=Get ( ScriptResult );

              match="<:" & Substitute( name ; ["="; "/="]; [":"; "/:"] ; [">"; "/>"]; ["<" ; "/<"]   ) & ":=";
              pstart = Position(dict; match; 1; 1);
              start = pstart + Length(match);
              end = Position(dict ; ":>"; start; 1);
              len = If(end = 0; 999999999; end - start)];

              If (pstart = 0; ""; 
              Substitute(Middle(dict; start; len); ["/:"; ":"]; ["/="; "="] ; ["/>"; ">"] ; ["/<" ; "<" ]))
)]]>
</Calculation>
  </CustomFunction>
  <CustomFunction id="4" functionArity="3" visible="True" parameters="dict;key;value" name="DictAfterKeyValue">
    <Calculation>
      <![CDATA[// DictAfterKeyValue ( dict; key; value )
// version 1.0, Daniel A. Shockley

// Returns part of the specified dictionary that occurs after (and including) the specified key/value pair. If not found, returns empty string.

Let( [
  kvPair = DictItem( key; value)
 ; kvPos = Position( dict; kvPair; 1; 1 )  // will be 0 if not within dict
];


If( kvPos 
  ; Right( dict; Length( dict ) - kvPos + 1 ) 
  ; ""
  )

)]]>
</Calculation>
  </CustomFunction>
  <CustomFunction id="5" functionArity="2" visible="True" parameters="dict;name" name="DictContains">
    <Calculation>
      <![CDATA[Let(
 pattern = "<:" & Substitute( name; ["="; "/="]; [":"; "/:"] ; [">"; "/>"]; ["<" ; "/<"]   ) & ":=";
 Position( dict; pattern; 1; 1 ) > 0
)]]>
</Calculation>
  </CustomFunction>
  <CustomFunction id="6" functionArity="2" visible="True" parameters="dict;name" name="DictCount">
    <Calculation>
      <![CDATA[// DictCount ( dict; name )
// version 1.0, Daniel A. Shockley

// This assumes that you have a non-standard dictionary, where a given key might exist more than once. It counts them. 

Let(
 pattern = "<:" & Substitute( name; ["="; "/="]; [":"; "/:"] ; [">"; "/>"]; ["<" ; "/<"]   ) & ":=";
 PatternCount( dict; pattern )
)]]>
</Calculation>
  </CustomFunction>
  <CustomFunction id="7" functionArity="1" visible="True" parameters="input" name="DictEscape">
    <Calculation>
      <![CDATA[Substitute( input; ["="; "/="]; [":"; "/:"] ; [">"; "/>"]; ["<" ; "/<"]   )]]>
</Calculation>
  </CustomFunction>
  <CustomFunction id="8" functionArity="1" visible="True" parameters="dict" name="DictFirst">
    <Calculation>
      <![CDATA[// DictFirst( dict )

// version 1.1, Daniel A. Shockley

// Properly unescapes the name of the item, since returning the escaped name is wrong. 
// Gets the NAME of the first parameter from a Dictionary object. 

Let(
   [startValue = "<:";
   endValue = ":=";
   positionOfStartValue= Position( dict ; startValue ; 1 ; 1 );
   endOfStartValue= If( positionOfStartValue > 0 ; positionOfStartValue  + Length(startvalue); -1 );
   beginningOfEndValue= Position( dict; endValue; endOfStartValue; 1 );
   found = If( beginningOfEndValue > -1 and endOfStartValue > -1 ; True; False );
   lengthFoundValue = beginningOfEndValue - endOfStartValue;
   foundValue = Middle( dict; endOfStartValue ; lengthFoundValue )];

   If( found ; DictUnescape( foundValue ) ; "" )
)]]>
</Calculation>
  </CustomFunction>
  <CustomFunction id="9" functionArity="2" visible="True" parameters="dict;name" name="DictGet">
    <Calculation>
      <![CDATA[Let( [
              match="<:" & Substitute( name ; ["="; "/="]; [":"; "/:"] ; [">"; "/>"]; ["<" ; "/<"]   ) & ":=";
              pstart = Position(dict; match; 1; 1);
              start = pstart + Length(match);
              end = Position(dict ; ":>"; start; 1);
              len = If(end = 0; 999999999; end - start)];

              If (pstart = 0; ""; 
              Substitute(Middle(dict; start; len); ["/:"; ":"]; ["/="; "="] ; ["/>"; ">"] ; ["/<" ; "<" ]))
)]]>
</Calculation>
  </CustomFunction>
  <CustomFunction id="10" functionArity="2" visible="True" parameters="name;value" name="DictItem">
    <Calculation>
      <![CDATA["<:" & DictEscape( name ) & ":=" 
                & DictEscape( value ) & ":>"]]>
</Calculation>
  </CustomFunction>
  <CustomFunction id="11" functionArity="1" visible="True" parameters="dict" name="DictListKeys">
    <Calculation>
      <![CDATA[// DictListKeys( dict )
// version 1.0
// Lists all of the keys present in a dictionary object (as used by SixFriedRice.com).

Let( [
firstKeyName = DictFirst( dict );
nextKeyName = If( Length( firstKeyName ) > 0; DictFirst( DictRemove( dict; firstKeyName ) ); "" );
       // Need to get next key so that we know whether to put in the line return (if no next, don't put in the separator)

done=True];

If( Length( firstKeyName ) > 0
  ; firstKeyName & If( Length( nextKeyName ) = 0; ""; "¶" & DictListKeys( DictRemove( dict; firstKeyName ) ) )
  ; ""
  )

)]]>
</Calculation>
  </CustomFunction>
  <CustomFunction id="12" functionArity="2" visible="True" parameters="dict;name" name="DictRemove">
    <Calculation>
      <![CDATA[// DictRemove( dict; name )

Let(
[
pattern = "<:" & DictEscape( name ) & ":=";
 entry_start = Position( dict ; pattern ; 1 ; 1);
 entry_end = Position( dict ; ":>" ; entry_start + 1; 1);
 dict_beginning = If( entry_start > 0 ; Left ( dict ; entry_start - 1 ) );
 rest_of_dict = Middle( dict ; entry_end + 2 ; Length( dict ) );
 new_dict = dict_beginning & rest_of_dict
];
If( entry_start > 0 ; new_dict ; dict )
)]]>
</Calculation>
  </CustomFunction>
  <CustomFunction id="13" functionArity="3" visible="True" parameters="dict;name;newValue" name="DictReplace">
    <Calculation>
      <![CDATA[// DictReplace( dict; name; newValue )


DictRemove( dict; name ) & #( name; newValue )]]>
</Calculation>
  </CustomFunction>
  <CustomFunction id="14" functionArity="3" visible="True" parameters="dict;keys;outdelimiter" name="DictToDelimitedList">
    <Calculation>
      <![CDATA[/*// DictToDelimitedList( dict; keys; outdelimiter )
// version 1.0
// Grabs the values from a dictionary object (as used by SixFriedRice.com) that belong to the key(s) (return-delimited) listed, separating each by the delimiter specified. If there are multiple ocurrences of a key, EACH value will be returned.

Let(

firstKeyName = DictFirst( dict ); 

If( Length( firstKeyName ) = 0
  ; ""
  ; Let( [
         firstKeyIsWanted = ValueIsInList( keys; firstKeyName );
         restOfDict = DictRemove( dict; firstKeyName );
//         nextKeyIsWanted = If( Length( firstKeyName ) > 0; valueisinlist( keys; restOfDict; "" );
         
         done=True];

        Case( 
            firstKeyIsWanted
            ; AppendWithSeparator ( DictGet( dict; firstKeyName ) ; DictToDelimitedList ( restOfDict; keys; outdelimiter ) ; outdelimiter )
            ; 
            DictToDelimitedList ( restOfDict; keys; outdelimiter )
            )
       )
  )
)*/]]>
</Calculation>
  </CustomFunction>
  <CustomFunction id="15" functionArity="2" visible="True" parameters="dict;subLevel" name="DictToJSON">
    <Calculation>
      <![CDATA[// DictToJSON( dict; subLevel )
// version 1.1, Daniel A. Shockley

/* Displays a SixFriedRice.com-style Dictionary as JSON to make it easier to read by a human. 


VERSION HISTORY:
1.1 - fixed a bug where there would be a trailing comma.
1.0 - initial version.

EXAMPLE USE: 
If the variable $someDictionary is set to: 
-----------------------
   #( "FirstName"; "Bob" ) 
& #( "LastName"; "Smith" ) 
&  #( "PhoneList"
       ; #( "Phone"
              ; #( "Label"; "Home" ) & #( "Value"; "212-123-4567" )
              )
       & #( "Phone"
              ; #( "Label"; "Cell" ) & #( "Value"; "212-999-9876" )
              )
       )
-----------------------
and thus $someDictionary looks like this in the debugger:
-----------------------
<:FirstName:=Bob:><:LastName:=Smith:><:PhoneList:=/</:Phone/:/=//<//:Label//://=Home//://>//<//:Value//://=212-123-4567//://>/:/>/</:Phone/:/=//<//:Label//://=Cell//://>//<//:Value//://=212-999-9876//://>/:/>:>
-----------------------

Using DictToJSON( $someDictionary; "" ) will give the much-easier-to-read display:
-----------------------
{
    "FirstName": "Bob", 
    "LastName": "Smith", 
    "PhoneList": 
    {
        "Phone": 
        {
            "Label": "Home", 
            "Value": "212-123-4567"
        }, 
        "Phone": 
        {
            "Label": "Cell", 
            "Value": "212-999-9876"
        }
    }
}
-----------------------

*/

Let( [
   
   indentPattern = "    "   // character(s) to use as prefix for each level of indentation
 ; subLevel = If( IsEmpty( subLevel ); 0; subLevel )  // identifies what is current level of indent
 ; firstKey  = DictFirst ( dict ) 
]; 

If( IsEmpty( firstKey ) 
  ; ""
  ; Let( [
         rawData = DictGet( dict; firstKey ) 
        ; valueAsDict = If( IsEmpty( DictFirst( rawData ) ) ; ""; "¶" & indentPattern & Substitute( DictToJSON( rawData; subLevel + 1 ); "¶"; "¶" & indentPattern ) ) 
        ; rest = DictRemove( dict ; firstKey ) 
        ];

       If( subLevel = 0; "{¶" )
       & indentPattern 
       & If( IsEmpty( valueAsDict )
           ; Quote( firstKey ) & ": " & Quote( rawData )
           ; Quote( firstKey ) & ": ¶" & indentPattern & "{" & valueAsDict & "¶" & indentPattern & "}"
           )
       & Case( not IsEmpty( DictFirst( rest ) ) 
          ; ", ¶" & DictToJSON( rest; subLevel + 1 )
          ; ""
          )
       & If( subLevel = 0; "¶}" )
       )
  )
)]]>
</Calculation>
  </CustomFunction>
  <CustomFunction id="16" functionArity="1" visible="True" parameters="dict" name="DictToVariables">
    <Calculation>
      <![CDATA[// DictToVariables( dict )
// version 1.0, Daniel A. Shockley, NYHTC

// Converts a dictionary object (as used by SixFriedRice.com) into script variables (single $), scoped to exist within the script that calls this function. 

Let( [
firstKeyName = DictFirst( dict );
makeVar = "Let( $" & firstKeyName  & " = " & Quote( DictGet( dict; firstKeyName ) ) & "; \"$" & firstKeyName & "\" )";
nextKeyName = If( Length( firstKeyName ) > 0; DictFirst( DictRemove( dict; firstKeyName ) ); "" );

done=True];

If( Length( firstKeyName ) > 0
  ; Evaluate( makeVar ) & If( Length( nextKeyName ) = 0; ""; "¶" & DictToVariables( DictRemove( dict; firstKeyName ) ) )
  ; ""
  )

)]]>
</Calculation>
  </CustomFunction>
  <CustomFunction id="17" functionArity="1" visible="True" parameters="input" name="DictUnescape">
    <Calculation>
      <![CDATA[Substitute( input; ["/:"; ":"]; ["/="; "="] ; ["/>"; ">"] ; ["/<" ; "<" ] )]]>
</Calculation>
  </CustomFunction>
  <CustomFunction id="18" functionArity="1" visible="True" parameters="ErrorNum" name="ErrorCode">
    <Calculation>
      <![CDATA[// ErrorCode( ErrorNum )

"ERROR " & ErrorNum & ": "  & 
Case(
ErrorNum = -1 ; "Unknown error"; 
// ErrorNum = 0 ; "No error";
ErrorNum = 1 ; "User canceled action";
ErrorNum = 2 ; "Memory error"; 
ErrorNum = 3 ; "Command is unavailable (for example, wrong operating system, wrong mode, etc.)"; 
ErrorNum = 4 ; "Command is unknown"; 
ErrorNum = 5 ; "Command is invalid (for example, a Set Field script step does not have a calculation specified)"; 
ErrorNum = 6 ; "File is read-only"; 
ErrorNum = 7 ; "Running out of memory"; 
ErrorNum = 8 ; "Empty result"; 
ErrorNum = 9 ; "Insufficient privileges"; 
ErrorNum = 10 ; "Requested data is missing"; 
ErrorNum = 11 ; "Name is not valid"; 
ErrorNum = 12 ; "Name already exists"; 
ErrorNum = 13 ; "File or object is in use"; 
ErrorNum = 14 ; "Out of range"; 
ErrorNum = 15 ; "Can't divide by zero"; 
ErrorNum = 16 ; "Operation failed, request retry (for example, a user query)"; 
ErrorNum = 17 ; "Attempt to convert foreign character set to UTF-16 failed"; 
ErrorNum = 18 ; "Client must provide account information to proceed"; 
ErrorNum = 19 ; "String contains characters other than A-Z, a-z, 0-9 (ASCII)"; 
ErrorNum = 100 ; "File is missing"; 
ErrorNum = 101 ; "Record is missing"; 
ErrorNum = 102 ; "Field is missing"; 
ErrorNum = 103 ; "Relationship is missing"; 
ErrorNum = 104 ; "Script is missing"; 
ErrorNum = 105 ; "Layout is missing"; 
ErrorNum = 106 ; "Table is missing"; 
ErrorNum = 107 ; "Index is missing"; 
ErrorNum = 108 ; "Value list is missing"; 
ErrorNum = 109 ; "Privilege set is missing"; 
ErrorNum = 110 ; "Related tables are missing"; 
ErrorNum = 111 ; "Field repetition is invalid"; 
ErrorNum = 112 ; "Window is missing"; 
ErrorNum = 113 ; "Function is missing"; 
ErrorNum = 114 ; "File reference is missing"; 
ErrorNum = 115 ; "Specified menu set is not present"; 
ErrorNum = 116 ; "Specified layout object is not present"; 
ErrorNum = 117 ; "Specified data source is not present"; 
ErrorNum = 130 ; "Files are damaged or missing and must be reinstalled"; 
ErrorNum = 131 ; "Language pack files are missing (such as template files)"; 
ErrorNum = 200 ; "Record access is denied"; 
ErrorNum = 201 ; "Field cannot be modified"; 
ErrorNum = 202 ; "Field access is denied"; 
ErrorNum = 203 ; "No records in file to print, or password doesn't allow print access"; 
ErrorNum = 204 ; "No access to field(s) in sort order"; 
ErrorNum = 205 ; "User does not have access privileges to create new records; import will overwrite existing data"; 
ErrorNum = 206 ; "User does not have password change privileges, or file is not modifiable"; 
ErrorNum = 207 ; "User does not have sufficient privileges to change database schema, or file is not modifiable"; 
ErrorNum = 208 ; "Password does not contain enough characters"; 
ErrorNum = 209 ; "New password must be different from existing one"; 
ErrorNum = 210 ; "User account is inactiveUser account is inactive"; 
ErrorNum = 211 ; "Password has expired"; 
ErrorNum = 212 ; "Invalid user account and/or password. Please try again"; 
ErrorNum = 213 ; "User account and/or password does not exist"; 
ErrorNum = 214 ; "Too many login attempts"; 
ErrorNum = 215 ; "Administrator privileges cannot be duplicated"; 
ErrorNum = 216 ; "Guest account cannot be duplicated"; 
ErrorNum = 217 ; "User does not have sufficient privileges to modify administrator accountUser does not have sufficient privileges to modify administrator account"; 
ErrorNum = 300 ; "File is locked or in use"; 
ErrorNum = 301 ; "Record is in use by another user"; 
ErrorNum = 302 ; "Table is in use by another user"; 
ErrorNum = 303 ; "Database schema is in use by another user"; 
ErrorNum = 304 ; "Layout is in use by another user"; 
ErrorNum = 306 ; "Record modification ID does not match"; 
ErrorNum = 400 ; "Find criteria are empty"; 
ErrorNum = 401 ; "No records match the request"; 
ErrorNum = 402 ; "Selected field is not a match field for a lookup"; 
ErrorNum = 403 ; "Exceeding maximum record limit for trial version of FileMaker Pro"; 
ErrorNum = 404 ; "Sort order is invalid"; 
ErrorNum = 405 ; "Number of records specified exceeds number of records that can be omitted"; 
ErrorNum = 406 ; "Replace/Reserialize criteria are invalid"; 
ErrorNum = 407 ; "One or both match fields are missing (invalid relationship)"; 
ErrorNum = 408 ; "Specified field has inappropriate data type for this operation"; 
ErrorNum = 409 ; "Import order is invalid"; 
ErrorNum = 410 ; "Export order is invalid"; 
ErrorNum = 412 ; "Wrong version of FileMaker Pro used to recover file"; 
ErrorNum = 413 ; "Specified field has inappropriate field type"; 
ErrorNum = 414 ; "Layout cannot display the result"; 
ErrorNum = 415 ; "One or more required related records are not available"; 
ErrorNum = 416 ; "Primary key required from data source table"; 
ErrorNum = 417 ; "Database is not supported for ODBC operations"; 
ErrorNum = 500 ; "Date value does not meet validation entry options"; 
ErrorNum = 501 ; "Time value does not meet validation entry options"; 
ErrorNum = 502 ; "Number value does not meet validation entry options"; 
ErrorNum = 503 ; "Value in field is not within the range specified in validation entry options"; 
ErrorNum = 504 ; "Value in field is not unique as required in validation entry options"; 
ErrorNum = 505 ; "Value in field is not an existing value in the database file as required in validation entry options"; 
ErrorNum = 506 ; "Value in field is not listed on the value list specified in validation entry option"; 
ErrorNum = 507 ; "Value in field failed calculation test of validation entry option"; 
ErrorNum = 508 ; "Invalid value entered in Find mode"; 
ErrorNum = 509 ; "Field requires a valid value"; 
ErrorNum = 510 ; "Related value is empty or unavailable"; 
ErrorNum = 511 ; "Value in field exceeds maximum number of allowed characters"; 
ErrorNum = 512 ; "Record was already modified by another user"; 
ErrorNum = 513 ; "Record must have a value in some field to be created"; 
ErrorNum = 600 ; "Print error has occurred"; 
ErrorNum = 601 ; "Combined header and footer exceed one page"; 
ErrorNum = 602 ; "Body doesn't fit on a page for current column setup"; 
ErrorNum = 603 ; "Print connection lost"; 
ErrorNum = 700 ; "File is of the wrong file type for import"; 
ErrorNum = 706 ; "EPSF file has no preview image"; 
ErrorNum = 707 ; "Graphic translator cannot be found"; 
ErrorNum = 708 ; "Can't import the file or need color monitor support to import file"; 
ErrorNum = 709 ; "QuickTime movie import failed"; 
ErrorNum = 710 ; "Unable to update QuickTime reference because the database file is read-only"; 
ErrorNum = 711 ; "Import translator cannot be found"; 
ErrorNum = 714 ; "Password privileges do not allow the operation"; 
ErrorNum = 715 ; "Specified Excel worksheet or named range is missing"; 
ErrorNum = 716 ; "A SQL query using DELETE, INSERT, or UPDATE is not allowed for ODBC import"; 
ErrorNum = 717 ; "There is not enough XML/XSL information to proceed with the import or export"; 
ErrorNum = 718 ; "Error in parsing XML file (from Xerces)"; 
ErrorNum = 719 ; "Error in transforming XML using XSL (from Xalan)"; 
ErrorNum = 720 ; "Error when exporting; intended format does not support repeating fields"; 
ErrorNum = 721 ; "Unknown error occurred in the parser or the transformer"; 
ErrorNum = 722 ; "Cannot import data into a file that has no fields"; 
ErrorNum = 723 ; "You do not have permission to add records to or modify records in the target table"; 
ErrorNum = 724 ; "You do not have permission to add records to the target table"; 
ErrorNum = 725 ; "You do not have permission to modify records in the target table"; 
ErrorNum = 726 ; "There are more records in the import file than in the target table. Not all records were imported"; 
ErrorNum = 727 ; "There are more records in the target table than in the import file. Not all records were updated"; 
ErrorNum = 729 ; "Errors occurred during import. Records could not be imported"; 
ErrorNum = 730 ; "Unsupported Excel version. (Convert file to Excel 7.0 (Excel 95), Excel 97, 2000, or XP format and try again)"; 
ErrorNum = 731 ; "The file you are importing from contains no data"; 
ErrorNum = 732 ; "This file cannot be inserted because it contains other files"; 
ErrorNum = 733 ; "A table cannot be imported into itself"; 
ErrorNum = 734 ; "This file type cannot be displayed as a picture"; 
ErrorNum = 735 ; "This file type cannot be displayed as a picture. It will be inserted and displayed as a file"; 
ErrorNum = 736 ; "Too much data to export to this format. It will be truncated"; 
ErrorNum = 800 ; "Unable to create file on disk"; 
ErrorNum = 801 ; "Unable to create temporary file on System disk"; 
ErrorNum = 802 ; "Unable to open file"; 
ErrorNum = 803 ; "File is single user or host cannot be found"; 
ErrorNum = 804 ; "File cannot be opened as read-only in its current state"; 
ErrorNum = 805 ; "File is damaged; use Recover command"; 
ErrorNum = 806 ; "File cannot be opened with this version of FileMaker Pro"; 
ErrorNum = 807 ; "File is not a FileMaker Pro file or is severely damaged"; 
ErrorNum = 808 ; "Cannot open file because access privileges are damaged"; 
ErrorNum = 809 ; "Disk/volume is full"; 
ErrorNum = 810 ; "Disk/volume is locked"; 
ErrorNum = 811 ; "Temporary file cannot be opened as FileMaker Pro file";
ErrorNum = 813 ; "Record Synchronization error on network"; 
ErrorNum = 814 ; "File(s) cannot be opened because maximum number is open"; 
ErrorNum = 815 ; "Couldn't open lookup file"; 
ErrorNum = 816 ; "Unable to convert file"; 
ErrorNum = 817 ; "Unable to open file because it does not belong to this solution"; 
ErrorNum = 819 ; "Cannot save a local copy of a remote file"; 
ErrorNum = 820 ; "File is in the process of being closed"; 
ErrorNum = 821 ; "Host forced a disconnect"; 
ErrorNum = 822 ; "FMI files not found; reinstall missing files"; 
ErrorNum = 823 ; "Cannot set file to single-user, guests are connected"; 
ErrorNum = 824 ; "File is damaged or not a FileMaker file"; 
ErrorNum = 900 ; "General spelling engine error"; 
ErrorNum = 901 ; "Main spelling dictionary not installed"; 
ErrorNum = 902 ; "Could not launch the Help system"; 
ErrorNum = 903 ; "Command cannot be used in a shared file"; 
ErrorNum = 905 ; "No active field selected; command can only be used if there is an active field"; 
ErrorNum = 906 ; "Current file must be shared in order to use this command"; 
ErrorNum = 920 ; "Can't initialize the spelling engine"; 
ErrorNum = 921 ; "User dictionary cannot be loaded for editing"; 
ErrorNum = 922 ; "User dictionary cannot be found"; 
ErrorNum = 923 ; "User dictionary is read-only"; 
ErrorNum = 951 ; "An unexpected error occurred (*)"; 
ErrorNum = 954 ; "Unsupported XML grammar (*)"; 
ErrorNum = 955 ; "No database name (*)"; 
ErrorNum = 956 ; "Maximum number of database sessions exceeded (*)"; 
ErrorNum = 957 ; "Conflicting commands (*)"; 
ErrorNum = 958 ; "Parameter missing (*)"; 
ErrorNum = 1200 ; "Generic calculation error"; 
ErrorNum = 1201 ; "Too few parameters in the function"; 
ErrorNum = 1202 ; "Too many parameters in the function"; 
ErrorNum = 1203 ; "Unexpected end of calculation"; 
ErrorNum = 1204 ; "Number, text constant, field name or ( expected"; 
ErrorNum = 1205 ; "Comment is not terminated with *\/" ; 
ErrorNum = 1206 ; "Text constant must end with a quotation mark"; 
ErrorNum = 1207 ; "Unbalanced parenthesis"; 
ErrorNum = 1208 ; "Operator missing, function not found or ( not expected"; 
ErrorNum = 1209 ; "Name (such as field name or layout name) is missing"; 
ErrorNum = 1210 ; "Plug-in function has already been registered"; 
ErrorNum = 1211 ; "List usage is not allowed in this function"; 
ErrorNum = 1212 ; "An operator (for example, +, -, *) is expected here"; 
ErrorNum = 1213 ; "This variable has already been defined in the Let function"; 
ErrorNum = 1214 ; "AVERAGE, COUNT, EXTEND, GETREPETITION, MAX, MIN, NPV, STDEV, SUM and GETSUMMARY: expression found where a field alone is needed"; 
ErrorNum = 1215 ; "This parameter is an invalid Get function parameter"; 
ErrorNum = 1216 ; "Only Summary fields allowed as first argument in GETSUMMARY"; 
ErrorNum = 1217 ; "Break field is invalid"; 
ErrorNum = 1218 ; "Cannot evaluate the number"; 
ErrorNum = 1219 ; "A field cannot be used in its own formula"; 
ErrorNum = 1220 ; "Field type must be normal or calculated"; 
ErrorNum = 1221 ; "Data type must be number, date, time, or timestamp"; 
ErrorNum = 1222 ; "Calculation cannot be stored"; 
ErrorNum = 1223 ; "The function is not implemented"; 
ErrorNum = 1224 ; "The function is not defined"; 
ErrorNum = 1225 ; "The function is not supported in this context"; 
ErrorNum = 1300 ; "The specified name can't be used"; 
ErrorNum = 1400 ; "ODBC driver initialization failed; make sure the ODBC drivers are properly installed"; 
ErrorNum = 1401 ; "Failed to allocate environment (ODBC)"; 
ErrorNum = 1402 ; "Failed to free environment (ODBC)"; 
ErrorNum = 1403 ; "Failed to disconnect (ODBC)"; 
ErrorNum = 1404 ; "Failed to allocate connection (ODBC)"; 
ErrorNum = 1405 ; "Failed to free connection (ODBC)"; 
ErrorNum = 1406 ; "Failed check for SQL API (ODBC)"; 
ErrorNum = 1407 ; "Failed to allocate statement (ODBC)"; 
ErrorNum = 1408 ; "Extended error (ODBC)"; 
ErrorNum = 1409 ; "Error (ODBC)"; 
ErrorNum = 1413 ; "Failed communication link ODBC ";

ErrorNum = 1450 ; "Action requires PHP privilege extension (*)" ;
ErrorNum = 1451 ; "Action requires that current file be remote" ;
ErrorNum = 1501 ; "SMTP authentication failed" ;
ErrorNum = 1502 ; "Connection refused by SMTP server" ;
ErrorNum = 1503 ; "Error with SSL" ;
ErrorNum = 1504 ; "SMTP server requires the connection to be encrypted" ;
ErrorNum = 1505 ; "Specified authentication is not supported by SMTP server" ;
ErrorNum = 1506 ; "Email(s) could not be sent successfully" ;
ErrorNum = 1507 ; "Unable to log in to the SMTP server" 
)]]>
</Calculation>
  </CustomFunction>
  <CustomFunction id="19" functionArity="4" visible="True" parameters="_Name_ID;_TLFSV;_fileName;_layoutName" name="FM_Name_ID">
    <Calculation>
      <![CDATA[// FM_Name_ID ( _Name_ID ; _TLFSV ; _fileName ; _layoutName )


/*
Fabrice Nordmann

Avoids hard-coding in FileMaker by using IDs instead of names

v.1.5.X3 (modification suggestion), Mar 2011 - suggestion by Daniel A. Shockley
   Dealt with bugs - use specified filename everywhere

v.1.5.X2 (modification suggestion), Dec 2010 - suggestion by Daniel A. Shockley
   Can now get the field name from a fully-qualified field ID ("tableID::fieldID") - use the BASE table. 

v.1.5.X1 (modification suggestion), Nov 2010 - suggestion by Daniel A. Shockley
   Added ability to get the ID for a Table Occurrence from a fully-qualified field name ("myTable::myField") - use the BASE table. 

v.1.5.1, Dec 2008
    Documentation update (thanks to Kevin Frank's comment)
v.1.5, Oct 2008
    Documentation error fix
    Returns an empty result if item not found
v.1.4, Aug 2008
    Bug fix (major) : could return erroneous result if an item ID was found in another ID.
v.1.3, July 2008
    A field ID can be obtained by passing its full name (with table occurrence) in _Name_ID and leaving _layoutName empty
    e.g.   FM_Name_ID ( "myTable::myField" ; "F" ; "" ; "" )
v.1.2, June 2008
    Doesn't require Position value
v.1, May 2008
    Requires: PositionValue ( _text ; _searchValue ; _start ; _occurrence )

if _Name_ID is an ID, returns the name
if _Name_ID is a name, returns the ID

_Name_ID is the name or the ID of a Table occurrence, a layout, or a field, a script or a value list
_TLFSV can be set to "Table", "Layout", "Field", "Script", or "ValueList". Or only the first character (T,L,F,S,V)
_fileName is optional (empty means current file)
_layoutName is valid only if _TLFSV contains "Field". Empty means current layout (or the field table occurrence, read the note below). The layout should be tied to the table occurrence of the field.

Note: for fields (_TLFSV = "F"), if you use the full field name (table::fieldname) AND an empty _layoutName parameter, the function will assume you are referring not to current layout but to the table occurrence found in the _TLFSV.  

Note: ALSO for fields (_TLFSV = "F"), if you want to get the field name from an ID without needing a specific layout, you can substitute the NAME of the TABLE for the layout parameter. Apparently, even if you don't have a layout named the same as a BaseTable, the FieldNames( fileName, layoutName) and FieldIDs( fileName, layoutName) functions will both allow table occurences in place of the layout's name for that parameter.

*/

Let ([ 
// _fileName is optional
  _fileName = Case ( IsEmpty ( _fileName ) ; Get ( FileName ) ; _fileName )
  
// layoutname is optional. If empty, use table part of fully-qualified field, or current layout. 
; _layoutName = Case ( IsEmpty ( _layoutName ) ; Case ( PatternCount ( _Name_ID ; "::" ) ; GetValue ( Substitute ( _Name_ID ; "::" ; ¶ ) ; 1 ) ; Get ( LayoutName )) ; _layoutName )
; _p = _Name_ID

// allow _TLFSV to be only the first character (T,L,F,S,V)
; _t = Left ( _TLFSV ; 1 )
; _t = Case ( _t = "T" ; "Table" ; _t = "L" ; "Layout" ; _t = "F" ; "Field" ; _t = "S" ; "Script" ; _t = "V" ; "ValueList" )
; _layoutName = If( _t = "Field" and _layoutName = GetAsNumber( _layoutName ); FM_Name_ID( _layoutName; "T"; _filename; "" ); _layoutName )  // allow TableID::FieldID parameter 
; _p = Case ( _t = "Field" and PatternCount ( _p ; "::" ) ; Replace ( _p ; 1 ; Position ( _p ; "::" ; 1 ; 1 ) + 1 ; "" ) ; _p )     // for fields, do not take TO
; _p = Case ( _t = "Table" and PatternCount ( _p ; "::" ) ; Left ( _p ; Position ( _p ; "::" ; 1 ; 1 ) - 1 ) ; _p )     // for tables, do not take the field-name part, if there is one
; _endOfString = "( \"" & _fileName & "\"" & Case ( _t = "Field" ; "; \"" & _layoutName & "\"" ) & ")"
; _names = Evaluate ( _t & "Names" & _endOfString )
; _ids =      Evaluate ( _t & "IDs" & _endOfString )
];

Case ( _p = GetAsNumber ( _p )
// ID -> Name
; Case ( not IsEmpty ( FilterValues ( _p ; _ids )) ; GetValue ( _names ; Let ([ _text = _ids ; _item = _p ; _adj = ¶ & _text & ¶ ] ; PatternCount ( Left ( _adj ; Position ( _adj ; ¶ & _item & ¶ ; 1 ; 1 ) + 1 ) ; ¶ ))))
// Name -> ID
; Case ( not IsEmpty ( FilterValues ( _p ; _names )) ; GetValue ( _ids ; Let ([ _text = _names ; _item = _p ; _adj = ¶ & _text & ¶ ] ; PatternCount ( Left ( _adj ; Position ( _adj ; ¶ & _item & ¶ ; 1 ; 1 ) + 1 ) ; ¶ ))))

)
)]]>
</Calculation>
  </CustomFunction>
  <CustomFunction id="20" functionArity="1" visible="True" parameters="layout" name="GetLayoutID">
    <Calculation>
      <![CDATA[// GetLayoutID v1.0
Let ( [
       
       theLayout = If ( layout ="current" ; Get ( LayoutName ) ; layout );            
       theLayoutNames = LayoutNames ( Get ( FileName ) );
       currentLayoutPosition =  PatternCount (                                                 
                               Middle ( theLayoutNames ; 1 ;                  
                               Position ( theLayoutNames ; theLayout ; 1 ; 1 ) ) ;
                                               "¶" ) + 1 ;

       layoutIDs = LayoutIDs ( Get ( FileName ) ) ;
       numberOfLayouts = Get ( LayoutCount ) ;                      
       layoutID = Case (                                                                                   
                               currentLayoutPosition = 1 ; LeftWords ( layoutIDs ; 1 ) ;   
                               currentLayoutPosition < numberOfLayouts ; 
                                                       Middle ( layoutIDs ;
Position ( layoutIDs ; "¶" ; 1 ; currentLayoutPosition -1 ) ; Position ( layoutIDs ; "¶" ; 1 ; currentLayoutPosition ) - Position ( layoutIDs ; "¶" ; 1 ; currentLayoutPosition -1 ) ) ;
                                                                                                             
                               Middle ( layoutIDs ;                                                               
Position ( layoutIDs ; "¶" ; 1 ; currentLayoutPosition -1 ) ; Length ( layoutIDs ) ) ) ];

GetAsNumber ( layoutID ) )]]>
</Calculation>
  </CustomFunction>
</fmxmlsnippet>